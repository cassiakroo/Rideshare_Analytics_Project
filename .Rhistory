ORDER BY rank DESC
LIMIT 10
"
dbGetQuery(con, query_b)
library(DBI)
library(RMariaDB)
con <- dbConnect(MariaDB(),
host = "relational.fel.cvut.cz",
port = 3306,
username = "guest",
password = "ctu-relational",
dbname = "imdb_ijs"
)
query_b <- "
SELECT name, year, rank
FROM movies
WHERE year = (
SELECT MAX(year)
FROM movies
WHERE rank IS NOT NULL
)
AND rank IS NOT NULL
ORDER BY rank DESC
LIMIT 10
"
dbGetQuery(con, query_b)
query_c <- "
SELECT mg.genre, COUNT(m.rank) AS count, AVG(m.rank) AS avg_rating
FROM movies m
JOIN movies_genres mg ON m.id = mg.movie_id
WHERE m.rank IS NOT NULL
GROUP BY mg.genre
HAVING COUNT(m.rank) > 0
ORDER BY avg_rating DESC
"
genre_avg_rating <- dbGetQuery(con, query_c)
genre_avg_rating
hist(genre_avg_rating$avg_rating,
main = "Distribution of Average Ratings by Genre",
xlab = "Average Rating",
col = "lightblue",
border = "black")
knitr::opts_chunk$set(echo = TRUE)
hist(genre_avg_rating$avg_rating,
main = "Distribution of Average Ratings by Genre",
xlab = "Average Rating",
col = "lightpink",
border = "black")
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(dbplyr)
movies_directors_tbl <- tbl(con, "movies_directors")
library(DBI)
library(RMariaDB)
con <- dbConnect(MariaDB(),
host = "relational.fel.cvut.cz",
port = 3306,
username = "guest",
password = "ctu-relational",
dbname = "imdb_ijs"
)
library(dplyr)
library(dbplyr)
movies_directors_tbl <- tbl(con, "movies_directors")
directors_tbl <- tbl(con, "directors")
knitr::opts_chunk$set(echo = TRUE)
top_directors <- movies_directors_tbl %>%
inner_join(directors_tbl, by = c("director_id" = "id")) %>%
group_by(director_id, first_name, last_name) %>%
summarise(movie_count = n(), .groups = "drop") %>%
arrange(desc(movie_count)) %>%
head(10)
show_query(top_directors)
top_directors_result <- collect(top_directors)
top_directors_result
View(con)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(dbplyr)
md <- tbl(con, "movies_directors")
library(DBI)
library(RMariaDB)
con <- dbConnect(MariaDB(),
host = "relational.fel.cvut.cz",
port = 3306,
username = "guest",
password = "ctu-relational",
dbname = "imdb_ijs"
)
library(dplyr)
library(dbplyr)
md <- tbl(con, "movies_directors")
d <- tbl(con, "directors")
td <- md %>%
inner_join(d, by = c("director_id" = "id")) %>%
group_by(director_id, first_name, last_name) %>%
summarise(movie_count = n(), .groups = "drop") %>%
arrange(desc(movie_count)) %>%
head(10)
show_query(td)
td_result <- collect(td)
td_result
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
install.packages("reticulate")
library(reticulate)
use_virtualenv("stats167_venv", required = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
virtualenv_create("stats167_venv")
virtualenv_install("stats167_venv", packages = "pymysql")
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
use_virtualenv("~/.virtualenvs/stats167_venv", required = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_virtualenv("stats167_venv", required = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_virtualenv("stats167_venv", required = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_virtualenv("stats167_venv", required = TRUE)
reticulate::py_install("pandas", envname = "stats167_venv")
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_virtualenv("stats167_venv", required = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
cat("
WITH ranked_years AS (
SELECT *,
MAX(year) OVER () AS max_year
FROM movie_views
),
filtered_data AS (
SELECT *
FROM ranked_years
WHERE year >= 2010 AND year < max_year
),
cumulative_views AS (
SELECT movie_id, year,
SUM(views) OVER (
PARTITION BY movie_id
ORDER BY year
ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
) AS cumulative_3yr_views
FROM filtered_data
)
SELECT *
FROM cumulative_views
ORDER BY movie_id, year;
")
dbDisconnect(con)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
# Install packages if not already installed
install.packages(c("rvest", "httr", "dplyr", "stringr"))
# Load packages
library(rvest)
library(httr)
library(dplyr)
library(stringr)
# Set the URL and user agent
url <- "https://www.hltv.org/events/8436/blasttv-austin-major-2025-stage-1"
headers <- c("User-Agent" = "Mozilla/5.0")
# Read the HTML content
page <- httr::GET(url, httr::add_headers(.headers = headers))
html <- read_html(page)
library(httr)
library(rvest)
# Custom browser headers
headers <- add_headers(
`User-Agent` = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
`Accept-Language` = "en-US,en;q=0.9",
`Accept` = "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
`Connection` = "keep-alive"
)
# Try fetching the page again
url <- "https://www.hltv.org/events/8436/blasttv-austin-major-2025-stage-1"
res <- GET(url, headers)
# Check if successful
if (status_code(res) == 200) {
html <- read_html(res)
print("✅ Page successfully retrieved!")
} else {
stop(paste("❌ Failed with status:", status_code(res)))
}
# install first: pip install playwright && playwright install
from playwright.sync_api import sync_playwright
knitr::opts_chunk$set(echo = TRUE)
# brands
# - brand_id (PK)
# - name
# - contact_email
# - category
# campaigns
# - campaign_id (PK)
# - brand_id (FK → brands.brand_id)
# - product
# - deadline
# - compensation
# posts
# - post_id (PK)
# - campaign_id (FK → campaigns.campaign_id)
# - platform
# - date_posted
# - approved (logical)
# - engagement_rate
# brands
# - brand_id (PK)
# - name
# - contact_email
# - category
# campaigns
# - campaign_id (PK)
# - brand_id (FK → brands.brand_id)
# - product
# - deadline
# - compensation
# posts
# - post_id (PK)
# - campaign_id (FK → campaigns.campaign_id)
# - platform
# - date_posted
# - approved (logical)
# - engagement_rate
library(DiagrammeR)
install.packages("DiagrammeR")
library(DiagrammeR)
grViz("
digraph ERD {
graph [layout = dot, rankdir = LR]
node [shape = record, style = filled, fillcolor = lightgray]
brands [label = \"{brands | brand_id (PK) \\l name \\l contact_email \\l category \\l}\"]
campaigns [label = \"{campaigns | campaign_id (PK) \\l brand_id (FK) \\l product \\l deadline \\l compensation \\l}\"]
posts [label = \"{posts | post_id (PK) \\l campaign_id (FK) \\l platform \\l date_posted \\l approved \\l engagement_rate \\l}\"]
brands -> campaigns [label = \"1 to many\"]
campaigns -> posts [label = \"1 to many\"]
}
")
library(DBI)
library(RSQLite)
con <- dbConnect(RSQLite::SQLite(), "collab_tracker.db")
knitr::opts_chunk$set(echo = TRUE)
# brands
# - brand_id (PK)
# - name
# - contact_email
# - category
# campaigns
# - campaign_id (PK)
# - brand_id (FK → brands.brand_id)
# - product
# - deadline
# - compensation
# posts
# - post_id (PK)
# - campaign_id (FK → campaigns.campaign_id)
# - platform
# - date_posted
# - approved (logical)
# - engagement_rate
library(DiagrammeR)
grViz("
digraph ERD {
graph [layout = dot, rankdir = LR]
node [shape = record, style = filled, fillcolor = lightgray]
brands [label = \"{brands | brand_id (PK) \\l name \\l contact_email \\l category \\l}\"]
campaigns [label = \"{campaigns | campaign_id (PK) \\l brand_id (FK) \\l product \\l deadline \\l compensation \\l}\"]
posts [label = \"{posts | post_id (PK) \\l campaign_id (FK) \\l platform \\l date_posted \\l approved \\l engagement_rate \\l}\"]
brands -> campaigns [label = \"1 to many\"]
campaigns -> posts [label = \"1 to many\"]
}
")
library(DBI)
library(RSQLite)
con <- dbConnect(RSQLite::SQLite(), "collab_tracker.db")
dbExecute(con, "DROP TABLE IF EXISTS posts;")
dbExecute(con, "DROP TABLE IF EXISTS campaigns;")
dbExecute(con, "DROP TABLE IF EXISTS brands;")
dbExecute(con, "
CREATE TABLE brands (
brand_id INTEGER PRIMARY KEY,
name TEXT,
contact_email TEXT,
category TEXT
);
")
dbExecute(con, "
CREATE TABLE campaigns (
campaign_id INTEGER PRIMARY KEY,
brand_id INTEGER,
product TEXT,
deadline DATE,
compensation REAL,
FOREIGN KEY (brand_id) REFERENCES brands(brand_id)
);
")
dbExecute(con, "
CREATE TABLE posts (
post_id INTEGER PRIMARY KEY,
campaign_id INTEGER,
platform TEXT,
date_posted DATE,
approved BOOLEAN,
engagement_rate REAL,
FOREIGN KEY (campaign_id) REFERENCES campaigns(campaign_id)
);
")
dbExecute(con, "
INSERT INTO brands (brand_id, name, contact_email, category) VALUES
(1, 'Gisou', 'pr@gisou.com', 'Haircare'),
(2, 'Saie Beauty', 'collabs@saie.com', 'Makeup'),
(3, 'Ouai', 'hello@ouai.com', 'Haircare');
")
dbExecute(con, "
INSERT INTO campaigns (campaign_id, brand_id, product, deadline, compensation) VALUES
(1, 1, 'Honey Infused Hair Oil', '2025-06-12', 150),
(2, 2, 'Glowy Super Gel', '2025-06-20', 100),
(3, 3, 'Leave-In Conditioner', '2025-06-15', 200);
")
dbExecute(con, "
INSERT INTO posts (post_id, campaign_id, platform, date_posted, approved, engagement_rate) VALUES
(1, 1, 'TikTok', '2025-06-10', 1, 12.5),
(2, 2, 'Instagram', '2025-06-18', 0, 9.8),
(3, 1, 'Instagram', '2025-06-11', 1, 11.2),
(4, 3, 'TikTok', '2025-06-13', 1, 15.0);
")
dbGetQuery(con, "
SELECT c.campaign_id, b.name AS brand_name, c.product, c.deadline, c.compensation
FROM campaigns c
JOIN brands b ON c.brand_id = b.brand_id;
")
dbGetQuery(con, "
SELECT p.platform, p.engagement_rate, p.date_posted,
c.product, b.name AS brand
FROM posts p
JOIN campaigns c ON p.campaign_id = c.campaign_id
JOIN brands b ON c.brand_id = b.brand_id
WHERE p.engagement_rate > 10;
")
library(DBI)
library(RSQLite)
con <- dbConnect(RSQLite::SQLite(), "collab_tracker.db")
dbGetQuery(con, "
SELECT b.name AS brand, ROUND(AVG(p.engagement_rate), 2) AS avg_engagement
FROM brands b
JOIN campaigns c ON b.brand_id = c.brand_id
JOIN posts p ON c.campaign_id = p.campaign_id
GROUP BY b.name;
")
dbGetQuery(con, "
SELECT name
FROM brands
WHERE brand_id IN (
SELECT brand_id
FROM campaigns
GROUP BY brand_id
HAVING COUNT(*) > 1
);
")
dbGetQuery(con, "
SELECT name
FROM brands
WHERE brand_id IN (
SELECT brand_id
FROM campaigns
GROUP BY brand_id
HAVING COUNT(*) > 1
);
")
dbGetQuery(con, "
SELECT name
FROM brands
WHERE brand_id IN (
SELECT brand_id
FROM campaigns
GROUP BY brand_id
HAVING COUNT(*) > 1
);
")
dbExecute(con, "
INSERT INTO brands (brand_id, name, contact_email, category) VALUES
(1, 'Gisou', 'pr@gisou.com', 'Haircare'),
(2, 'Saie Beauty', 'collabs@saie.com', 'Makeup'),
(3, 'Ouai', 'hello@ouai.com', 'Haircare');
")
library(DBI)
library(RSQLite)
con <- dbConnect(RSQLite::SQLite(), "collab_tracker.db")
dbExecute(con, "DROP TABLE IF EXISTS posts;")
dbExecute(con, "DROP TABLE IF EXISTS campaigns;")
dbExecute(con, "DROP TABLE IF EXISTS brands;")
dbExecute(con, "
CREATE TABLE brands (
brand_id INTEGER PRIMARY KEY,
name TEXT,
contact_email TEXT,
category TEXT
);
")
dbExecute(con, "
CREATE TABLE campaigns (
campaign_id INTEGER PRIMARY KEY,
brand_id INTEGER,
product TEXT,
deadline DATE,
compensation REAL,
FOREIGN KEY (brand_id) REFERENCES brands(brand_id)
);
")
dbExecute(con, "
CREATE TABLE posts (
post_id INTEGER PRIMARY KEY,
campaign_id INTEGER,
platform TEXT,
date_posted DATE,
approved BOOLEAN,
engagement_rate REAL,
FOREIGN KEY (campaign_id) REFERENCES campaigns(campaign_id)
);
")
dbExecute(con, "
INSERT INTO brands (brand_id, name, contact_email, category) VALUES
(1, 'Gisou', 'pr@gisou.com', 'Haircare'),
(2, 'Saie Beauty', 'collabs@saie.com', 'Makeup'),
(3, 'Ouai', 'hello@ouai.com', 'Haircare');
")
dbExecute(con, "
INSERT INTO campaigns (campaign_id, brand_id, product, deadline, compensation) VALUES
(1, 1, 'Honey Infused Hair Oil', '2025-06-12', 150),
(2, 2, 'Glowy Super Gel', '2025-06-20', 100),
(3, 3, 'Leave-In Conditioner', '2025-06-15', 200);
")
dbExecute(con, "
INSERT INTO campaigns (campaign_id, brand_id, product, deadline, compensation)
VALUES (4, 1, 'Propolis Infused Hair Perfume', '2025-06-25', 180);
")
dbExecute(con, "
INSERT INTO posts (post_id, campaign_id, platform, date_posted, approved, engagement_rate) VALUES
(1, 1, 'TikTok', '2025-06-10', 1, 12.5),
(2, 2, 'Instagram', '2025-06-18', 0, 9.8),
(3, 1, 'Instagram', '2025-06-11', 1, 11.2),
(4, 3, 'TikTok', '2025-06-13', 1, 15.0);
")
dbGetQuery(con, "
SELECT c.campaign_id, b.name AS brand_name, c.product, c.deadline, c.compensation
FROM campaigns c
JOIN brands b ON c.brand_id = b.brand_id;
")
dbGetQuery(con, "
SELECT p.platform, p.engagement_rate, p.date_posted,
c.product, b.name AS brand
FROM posts p
JOIN campaigns c ON p.campaign_id = c.campaign_id
JOIN brands b ON c.brand_id = b.brand_id
WHERE p.engagement_rate > 10;
")
dbGetQuery(con, "
SELECT b.name AS brand, ROUND(AVG(p.engagement_rate), 2) AS avg_engagement
FROM brands b
JOIN campaigns c ON b.brand_id = c.brand_id
JOIN posts p ON c.campaign_id = p.campaign_id
GROUP BY b.name;
")
dbGetQuery(con, "
SELECT name
FROM brands
WHERE brand_id IN (
SELECT brand_id
FROM campaigns
GROUP BY brand_id
HAVING COUNT(*) > 1
);
")
dbGetQuery(con, "
WITH upcoming AS (
SELECT product, deadline
FROM campaigns
WHERE deadline BETWEEN DATE('now') AND DATE('now', '+7 days')
)
SELECT * FROM upcoming;
")
dbGetQuery(con, "
SELECT platform, post_id, engagement_rate,
RANK() OVER (PARTITION BY platform ORDER BY engagement_rate DESC) AS rank_within_platform
FROM posts;
")
GETWD()
getwd()
setwd("/Users/Cassia/Desktop/Rideshare_Analytics_Project")
